#include "lwip/igmp.h"
#include "lwip/ip4_addr.h"
#include "lwip/ip4.h"
#include "lwip/netif.h"

#include "geth_lwip.h"
#include "IfxStm.h"
#include "IfxGeth_Eth.h"
#include "IfxGeth.h"
#include "Configuration.h"
#include "ConfigurationIsr.h"
#include "Ifx_Lwip.h"
#include "IfxCpu_Irq.h"
#include "CompilerTasking.h"
#include "lwip/netif.h"
#include "etc.h"
#include "my_stdio.h"
#include <string.h>



static volatile int s_igmp_joined = 0;
static uint32_t s_link_stable_ticks = 0; // 링크/IPv4 올라온 뒤 안정화 대기용

static void on_netif_status(struct netif *n)
{
    my_printf("NETIF status: up=%d link=%d ip=0x%08lx\n",
              netif_is_up(n), netif_is_link_up(n), (unsigned long)netif_ip4_addr(n)->addr);

    // 아직 조건 미달이면 카운터 리셋하고 리턴
    if (!netif_is_up(n) || !netif_is_link_up(n) || netif_ip4_addr(n)->addr == 0) {
        s_link_stable_ticks = 0;
        return;
    }

    // 링크/IPv4가 붙은 뒤 500ms 안정화 대기
    if (s_link_stable_ticks < 500) { // 1ms tick 기준
        s_link_stable_ticks++;
        return;
    }

    // IGMP 플래그 세팅(한 번만)
    if (!(n->flags & NETIF_FLAG_IGMP)) {
        n->flags |= NETIF_FLAG_IGMP;
        my_printf("IGMP flag enabled on netif\n");
    }

    // 그룹 조인(한 번만)
    if (!s_igmp_joined) {
        ip4_addr_t sd_group;
        IP4_ADDR(&sd_group, 224, 244, 224, 245); // SOME/IP-SD 멀티캐스트

        err_t r;
    #if defined(LWIP_HAVE_IGMP_NETIF_API) || defined(igmp_joingroup_netif)
        r = igmp_joingroup_netif(n, &sd_group);
    #else
        const ip4_addr_t *ifaddr = netif_ip4_addr(n);
        r = igmp_joingroup(ifaddr, &sd_group);
    #endif
        my_printf("IGMP join ret=%d (224.244.224.245)\n", (int)r);
        if (r == ERR_OK) s_igmp_joined = 1;
    }
}



void initStmForLwip (void);

static uint8 g_srcAddr[6];

void initLwip(eth_addr_t mac)
{
    initStmForLwip();
    //MAC주소 저장
    for (int i = 0; i < 6; i++) {
        g_srcAddr[i] = mac.addr[i];
    }
    my_printf("Ifx_Lwip_init start\n");
    Ifx_Lwip_init(mac);
    my_printf("Ifx_Lwip_init done\n");

    delay_ms(3000);

    //added

    netif_set_status_callback(&g_Lwip.netif, on_netif_status);
    on_netif_status(&g_Lwip.netif);


//    while (netif_is_link_up(&g_Lwip.netif) == 0);
}

void initStmForLwip(void)
{
    IfxStm_CompareConfig stmCompareConfig; /* STM Configuration declaration                */

    IfxStm_initCompareConfig(&stmCompareConfig); /* Initialize a default configuration for STM   */

    stmCompareConfig.triggerPriority = ISR_PRIORITY_OS_TICK; /* Priority of the interrupt generated by STM   */
    stmCompareConfig.comparatorInterrupt = IfxStm_ComparatorInterrupt_ir0; /* Select the request source 0                  */
    stmCompareConfig.ticks = IFX_CFG_STM_TICKS_PER_MS * 10; /* First interrupt shall occur after 10 ms      */
    stmCompareConfig.typeOfService = IfxSrc_Tos_cpu0; /* CPU0 serves the interrupts                   */

    IfxStm_initCompare(&MODULE_STM0, &stmCompareConfig); /* Initialize the Compare functionality         */
}

/* This interrupt is raised by the STM0 */
IFX_INTERRUPT(updateLwIPStackISR, 0, ISR_PRIORITY_OS_TICK);
/* ISR to update LwIP stack */
void updateLwIPStackISR(void)
{
    /* Configure STM to generate an interrupt in 1 ms */
    IfxStm_increaseCompare(&MODULE_STM0, IfxStm_Comparator_0, IFX_CFG_STM_TICKS_PER_MS);

    g_TickCount_1ms++; /* Increase LwIP system time                                    */

    Ifx_Lwip_onTimerTick(); /* Every 1 ms LwIP timers are increased for all the enabled
                             * protocols (ARP, TCP, DHCP, LINK)                             */
}

void geth_sendETH(uint8 *destAddr, uint8 *payload, int payloadLength)
{
    uint32 packetLength = IFXGETH_HEADER_LENGTH + payloadLength;

    // get free buffer
    uint8 *pTxBuf = (uint8*)IfxGeth_Eth_waitTransmitBuffer(&g_IfxGeth, IfxGeth_TxDmaChannel_0);

    // write the header
    IfxGeth_Eth_writeHeader(&g_IfxGeth, pTxBuf, (uint8*)destAddr, (uint8*)g_srcAddr, payloadLength);

    uint16 etherType = 0x0000;
    pTxBuf[12] = (uint8)(etherType >> 8);
    pTxBuf[13] = (uint8)(etherType & 0xFF);

    // write the payload
    for (int i = IFXGETH_HEADER_LENGTH; i < packetLength; ++i)
    {
        pTxBuf[i] = payload[i - IFXGETH_HEADER_LENGTH];
    }

    // clear the TX interrupt status
    IfxGeth_dma_clearInterruptFlag(g_IfxGeth.gethSFR, IfxGeth_DmaChannel_0, IfxGeth_DmaInterruptFlag_transmitInterrupt);

    IfxGeth_Eth_sendTransmitBuffer(&g_IfxGeth, packetLength, IfxGeth_TxDmaChannel_0);

    // wait until buffer has been transmitted
    while (IfxGeth_dma_isInterruptFlagSet(g_IfxGeth.gethSFR, IfxGeth_DmaChannel_0,
            IfxGeth_DmaInterruptFlag_transmitInterrupt) == FALSE);

    // clear the TX interrupt status for the next interrupt to come
    IfxGeth_dma_clearInterruptFlag(g_IfxGeth.gethSFR, IfxGeth_DmaChannel_0, IfxGeth_DmaInterruptFlag_transmitInterrupt);
}

int geth_recvETH(uint8 *buf)
{
    // wait until data is been received
    while(IfxGeth_Eth_isRxDataAvailable(&g_IfxGeth, IfxGeth_RxDmaChannel_0)!= TRUE);
    // wake up the receiver and get the recieve buffer
    uint8 *pRxBuf = (uint8*)IfxGeth_Eth_getReceiveBuffer(&g_IfxGeth, IfxGeth_RxDmaChannel_0);
    int payloadLength = 0;
    while (pRxBuf[14+payloadLength] != 0) {
        payloadLength++;
    }
    memcpy(buf, pRxBuf, payloadLength);

    // update the descreptor pointer for next packet
    // Free the receive buffer, enabling it for the further reception
    IfxGeth_Eth_freeReceiveBuffer(&g_IfxGeth, IfxGeth_RxDmaChannel_0);

    return payloadLength;
}
